1. Binary tree is a tree data structure with a root node and have up to 2 child nodes, which each has up to 2 child nodes and so on.

2. Heuristics are guesses that an algorithm makes to solve a complex problem sooner by sacrificing accruracy.

3. Another problem besides the shortest-path problem that requires the use of heuristics is the possible educated guess.

4. Depth-first-search: starts at the root and explore as far as possible along each branch before backtracking.
   Breadth-first-search: BFS starts at the tree root and explore the neighbor nodes first, before moving to the next level neighbors.

5. An undirected, cyclic, unweighted graph means that there is a connection between 2 nodes, but don't form loop and do not carry the cost of travel between Nodes.

6. A binary search tree is directed, cyclic and unweighted.



1. To determine whether a node belongs to the tree or not, we start with comparing it with the root, if it's greater, travel right, otherwise goes left, and so on.

function search (nodeRoot, item) {
  if (nodeRoot === null) {
    return null;
  }
  if (nodeRoot === item) {
    return nodeRoot;
  } else if (nodeRoot.data < item) {
    return search(nodeRoot.right, item);          
  } else {
    return search(nodeRoot.left, item);
  }
}

2. Find the distance between the two nodes.

//distance bw 2 nodes = distance(root, n1) + distance(root, n2) - 2distance(root, lca);

function Node(data, left, right) {

		this.data = data;
		this.left = null;
		this.right = null;

}

function BinarySearchTree(root) {

		this.root = null;

}

BinarySearchTree.prototype.findDistanceBetweenTwoNodes = function(root, n1, n2) {

    var lca = this.findLowestCommonAncestor(root, n1, n2);
    var distanceNode1ToRoot = this.countDistanceToRoot(lca, n1);
    var distanceNode2ToRoot = this.countDistanceToRoot(lca, n2);
    var distanceRootToAncestor = this.countDistanceToRoot(root, lca);
    var totalDistance = (distanceNode1ToRoot + distanceNode2ToRoot) - (2 * distanceRootToAncestor);
    return ('Total distance between node ' + n1 + ' and node ' + n2 + ' is ' + totalDistance);

}

BinarySearchTree.prototype.findLowestCommonAncestor = function(root, n1, n2) {
    if (!root) return;

    var lca = root.data;

    else if (n1 === lca || n2 === lca) {
      return lca;
    }

    else if (n1 < lca && n2 < lca) {
      return this.findCommonAncestor(root.left, n1, n2);
    }

    else if (n1 > lca && n2 > lca) {
      return this.findCommonAncestor(root.right, n1, n2);
    }

    return lca;
}

BinarySearchTree.prototype.countDistanceToRoot = function(root, data) {
  var thisNode = this.root;

  var nodeCount = 0;

  while (thisNode) {

    if (data === thisNode.data) {
      return nodeCount;
    }

    thisNode = data < thisNode.data ? thisNode.left : thisNode.right;

    nodeCount++;
  }
}